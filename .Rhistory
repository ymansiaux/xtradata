typename = typename, key = key,
filter = filter_list_combined
)
# on vérifie que les résultats sont identiques
all.equal(res1, res2)
```
Il est possible de fournir un tableau de données dans l'argument filter
```{r filterAndFeatures}
filter_and_list <- list(
"gid" = list("$in" = c(50:55))
)
filter_and_JSON <- '{
"gid": {
"$in": [
50,51,52,53,54,55
]
}}'
res1 <- xtradata_requete_features(
typename = typename, key = key,
filter = filter_and_list
)
res2 <- xtradata_requete_features(
typename = typename, key = key,
filter = filter_and_JSON
)
# on vérifie que les résultats sont identiques
all.equal(res1, res2)
```
### Paramètre attributes
```{r attributesFeatures}
# 2 façons d'utiliser le paramètre attributes
attributes <- list("cdate", "mdate")
attributesArray <- '["cdate", "mdate"]'
filter_list <- list(
"type" = "BOUCLE",
"mdate" = list(
"$gt" = "2020-01-01T08:00:00"
)
)
res1 <- xtradata_requete_features(
typename = "PC_CAPTE_P", key = key,
filter = filter_list, attributes = attributes
)
res2 <- xtradata_requete_features(
typename = "PC_CAPTE_P", key = key,
filter = filter_list, attributes = attributesArray
)
# on vérifie que les résultats sont identiques
all.equal(res1, res2)
```
### Paramètre backintime
Ce paramètre permet d'accéder aux données de la couche sélectionnée à une date donnée.
#### Utilisation de l'argument backintime avec une date ou un datetime
```{r backintimeFeatures}
filter_list <- list(
"type" = "BOUCLE",
"mdate" = list(
"$gt" = "2020-01-01T08:00:00"
)
)
res1 <- xtradata_requete_features(
typename = typename, key = key,
filter = filter_list,
backintime = "2021-06-01T10:00:00"
)
tail(res1$mdate)
res2 <- xtradata_requete_features(
typename = typename, key = key,
filter = filter_list,
backintime = "2021-06-05"
)
tail(res2$mdate)
```
#### Utilisation de l'argument backintime avec une macro relative à la date / heure actuelle
```{r backintimeMacroFeatures}
res1 <- xtradata_requete_features(
typename = typename, key = key,
filter = filter_list,
backintime = "-30min"
)
tail(res1$mdate)
res2 <- xtradata_requete_features(
typename = typename, key = key,
filter = filter_list,
backintime = "-5hour"
)
tail(res2$mdate)
res3 <- xtradata_requete_features(
typename = typename, key = key,
filter = filter_list,
backintime = "-7day"
)
tail(res3$mdate)
res4 <- xtradata_requete_features(
typename = typename, key = key,
filter = filter_list,
backintime = "-1month"
)
tail(res4$mdate)
```
### Paramètre orderby
```{r orderbyFeatures}
# 2 façons d'utiliser le paramètre orderby
orderby <- list("mdate", "gid")
orderbyArray <- '["mdate", "gid"]'
res1 <- xtradata_requete_features(
typename = typename, key = key,
filter = filter_list,
orderby = orderby
)
res2 <- xtradata_requete_features(
typename = typename, key = key,
filter = filter_list,
orderby = orderbyArray
)
all.equal(res1, res2)
```
## Webservice aggregate
Ce webservice renvoie une aggregation des objets historisés sur une période et un pas de temps donné.
Pour obtenir davantage d'infos, consulter la documentation de la fonction xtradata_requete_aggregate ou la page dédiée de ce webservice [infos aggregate](http://http://data.bordeaux-metropole.fr/geojson/help/#/default/get_aggregate__typename_).
### Appel minimal
Les 3 paramètres requis sont le paramètre key (la clé d'accès), le paramètre typename (la couche de données à récupérer) et le paramètre rangeStart (le début de la période d'observation).
Les exemples fournis ensuite concernent la couche ST_PARK_P, qui décrit les [données temps réél des parkings hors voirie](https://opendata.bordeaux-metropole.fr/explore/dataset/st_park_p/information/).
Pour davantage d'informations sur les attributs présents dans une couche donnée, le dictionnaire [dicopub](https://data.bordeaux-metropole.fr/dicopub/#/dico) est une ressource indispensable.
```{r appelMinimalAggregate}
# Couche des capteurs de trafic auto
typename <- "ST_PARK_P"
# key <- "VOTRE_CLE_OPEN_DATA"
requete <- xtradata_requete_aggregate(key = key, typename = typename, rangeStart = Sys.Date()-1)
head(requete)
```
### Parametre filter
Le paramètre filter peut être fourni de 2 façons, soit sous forme d'une liste R, soit sous format d'une chaine de caractères avec un filtre écrit au format JSON (pratique pour faire des copier-coller depuis le service [swagger](http://data.bordeaux-metropole.fr/geojson/help/#/default/get_aggregate__typename_)
```{r filterAggregate}
filter_list <- list(
"ident" = "CUBPK88",
"etat" = "LIBRE",
"libres" = list(
"$gt" = 145
)
)
filterJSON <- '{
"ident": "CUBPK88",
"etat" : "LIBRE",
"libres": {
"$gt": 145
}
}'
date_deb <- "2021-06-01"
date_fin <- "2021-06-05"
# 2 façons d'utiliser le paramètre filter
res1 <- xtradata_requete_aggregate(
typename = typename, key = key,
rangeStart = date_deb,
rangeEnd = date_fin,
rangeStep = "hour",
filter = filter_list
)
res2 <- xtradata_requete_aggregate(
typename = typename, key = key,
rangeStart = date_deb,
rangeEnd = date_fin,
rangeStep = "hour",
filter = filterJSON
)
# on vérifie que les résultats sont identiques
all.equal(res1, res2)
```
### Parametre rangeFilter
Le paramètre rangeFilter peut également s'écrire de deux façons, de manière identique au paramètre filter
```{r rangeFilterAggregate}
rangeFilter_list <- list(
"hours" = 5:6,
"days" = 1:7,
"publicHolidays" = FALSE
)
rangeFilterJSON <- '{
"hours": [
5,6
],
"days": [
1,2,3,4,5,6,7
],
"publicHolidays": false
}'
res1 <- xtradata_requete_aggregate(
typename = typename, key = key,
rangeStart = date_deb,
rangeEnd = date_fin,
rangeStep = "hour",
filter = filter_list,
rangeFilter = rangeFilter_list
)
res2 <- xtradata_requete_aggregate(
typename = typename, key = key,
rangeStart = date_deb,
rangeEnd = date_fin,
rangeStep = "hour",
filter = filterJSON,
rangeFilter = rangeFilterJSON
)
# on vérifie que les résultats sont identiques
all.equal(res1, res2)
```
### Parametre attributes
#### Attributes sans précision d'opérateurs d'aggrégation
Dans ce cas les attributs numériques renverront la valeur moyenne et pour les autres types d'attributs, la première valeur sera retournée.
```{r attributesAggregate}
attributes_list <- list("gid", "libres")
attributesArray <- '["gid", "libres"]'
res1 <- xtradata_requete_aggregate(
typename = typename, key = key,
rangeStart = date_deb,
rangeEnd = date_fin,
rangeStep = "hour",
attributes = attributes_list,
filter = filter_list
)
res2 <- xtradata_requete_aggregate(
typename = typename, key = key,
rangeStart = date_deb,
rangeEnd = date_fin,
rangeStep = "hour",
attributes = attributesArray,
filter = filter_list
)
all.equal(res1, res2)
```
#### Attributes avec précision d'opérateurs d'aggrégation
L'ensemble des opérateurs autorisés sont détaillés dans la [documentation du webservice aggregate](http://data.bordeaux-metropole.fr/geojson/help/#/default/get_aggregate__typename_).
```{r attributesAggregateWithOperators}
attributes_key_value_list <- list("etat" = "first", "libres" = "max")
attributes_key_value_JSON <- '{"etat" : "first", "libres" : "max"}'
res1 <- xtradata_requete_aggregate(
typename = typename, key = key,
rangeStart = date_deb,
rangeEnd = date_fin,
rangeStep = "hour",
attributes = attributes_key_value_list,
filter = filter_list
)
res2 <- xtradata_requete_aggregate(
typename = typename, key = key,
rangeStart = date_deb,
rangeEnd = date_fin,
rangeStep = "hour",
attributes = attributes_key_value_JSON,
filter = filter_list
)
all.equal(res1, res2)
```
Les filtres sur un même champ doivent être combinés avec les opérateurs "$and", "$or", "$not" (voir les exemples fournis précédemment pour la fonction xtradata_requete_features).
knitr::opts_chunk$set(echo = TRUE)
library(xtradata)
key <- Sys.getenv("XTRADATA_KEY")
# Couche des capteurs de trafic auto
typename <- "PC_CAPTE_P"
# key <- "VOTRE_CLE_OPEN_DATA"
requete <- xtradata_requete_features(key = key, typename = typename)
head(requete)
lat_long <- get_latitude_longitude(requete)
head(lat_long)
filter_list <- list(
"type" = "BOUCLE",
"mdate" = list(
"$gt" = "2020-01-01T08:00:00"
)
)
filterJSON <- '{
"type": "BOUCLE",
"mdate": {
"$gt": "2020-01-01T08:00:00"
}
}'
# 2 façons d'utiliser le paramètre filter
res1 <- xtradata_requete_features(
typename = typename, key = key,
filter = filter_list
)
res2 <- xtradata_requete_features(
typename = typename, key = key,
filter = filterJSON
)
# on vérifie que les résultats sont identiques
all.equal(res1, res2)
filterJSON_combined <- '{
"$and": [
{ "gid": {"$gte": "1"} },
{ "gid": {"$lte": "5"} }
]
}'
filter_list_combined <- list(
"$and" = list(
list("gid" = list(
"$gte" = "1"
)),
list("gid" = list(
"$lte" = "5"
))
))
res1 <- xtradata_requete_features(
typename = typename, key = key,
filter = filterJSON_combined
)
res2 <- xtradata_requete_features(
typename = typename, key = key,
filter = filter_list_combined
)
# on vérifie que les résultats sont identiques
all.equal(res1, res2)
filter_and_list <- list(
"gid" = list("$in" = c(50:55))
)
filter_and_JSON <- '{
"gid": {
"$in": [
50,51,52,53,54,55
]
}}'
res1 <- xtradata_requete_features(
typename = typename, key = key,
filter = filter_and_list
)
res2 <- xtradata_requete_features(
typename = typename, key = key,
filter = filter_and_JSON
)
# on vérifie que les résultats sont identiques
all.equal(res1, res2)
# 2 façons d'utiliser le paramètre attributes
attributes <- list("cdate", "mdate")
attributesArray <- '["cdate", "mdate"]'
filter_list <- list(
"type" = "BOUCLE",
"mdate" = list(
"$gt" = "2020-01-01T08:00:00"
)
)
res1 <- xtradata_requete_features(
typename = "PC_CAPTE_P", key = key,
filter = filter_list, attributes = attributes
)
res2 <- xtradata_requete_features(
typename = "PC_CAPTE_P", key = key,
filter = filter_list, attributes = attributesArray
)
# on vérifie que les résultats sont identiques
all.equal(res1, res2)
filter_list <- list(
"type" = "BOUCLE",
"mdate" = list(
"$gt" = "2020-01-01T08:00:00"
)
)
res1 <- xtradata_requete_features(
typename = typename, key = key,
filter = filter_list,
backintime = "2021-06-01T10:00:00"
)
tail(res1$mdate)
res2 <- xtradata_requete_features(
typename = typename, key = key,
filter = filter_list,
backintime = "2021-06-05"
)
tail(res2$mdate)
res1 <- xtradata_requete_features(
typename = typename, key = key,
filter = filter_list,
backintime = "-30min"
)
tail(res1$mdate)
res2 <- xtradata_requete_features(
typename = typename, key = key,
filter = filter_list,
backintime = "-5hour"
)
tail(res2$mdate)
res3 <- xtradata_requete_features(
typename = typename, key = key,
filter = filter_list,
backintime = "-7day"
)
tail(res3$mdate)
res4 <- xtradata_requete_features(
typename = typename, key = key,
filter = filter_list,
backintime = "-1month"
)
tail(res4$mdate)
# 2 façons d'utiliser le paramètre orderby
orderby <- list("mdate", "gid")
orderbyArray <- '["mdate", "gid"]'
res1 <- xtradata_requete_features(
typename = typename, key = key,
filter = filter_list,
orderby = orderby
)
res2 <- xtradata_requete_features(
typename = typename, key = key,
filter = filter_list,
orderby = orderbyArray
)
all.equal(res1, res2)
# Couche des capteurs de trafic auto
typename <- "ST_PARK_P"
# key <- "VOTRE_CLE_OPEN_DATA"
requete <- xtradata_requete_aggregate(key = key, typename = typename, rangeStart = Sys.Date()-1)
head(requete)
filter_list <- list(
"ident" = "CUBPK88",
"etat" = "LIBRE",
"libres" = list(
"$gt" = 145
)
)
filterJSON <- '{
"ident": "CUBPK88",
"etat" : "LIBRE",
"libres": {
"$gt": 145
}
}'
date_deb <- "2021-06-01"
date_fin <- "2021-06-05"
# 2 façons d'utiliser le paramètre filter
res1 <- xtradata_requete_aggregate(
typename = typename, key = key,
rangeStart = date_deb,
rangeEnd = date_fin,
rangeStep = "hour",
filter = filter_list
)
res2 <- xtradata_requete_aggregate(
typename = typename, key = key,
rangeStart = date_deb,
rangeEnd = date_fin,
rangeStep = "hour",
filter = filterJSON
)
# on vérifie que les résultats sont identiques
all.equal(res1, res2)
res1
res2
res1 <- xtradata_requete_aggregate(
typename = typename, key = key,
rangeStart = date_deb,
rangeEnd = date_fin,
rangeStep = "hour",
group = "time+gid",
attributes = list("gid", "libres")
)
res2 <- xtradata_requete_aggregate(
typename = typename, key = key,
rangeStart = date_deb,
rangeEnd = date_fin,
rangeStep = "hour",
group = "time",
attributes = list("gid", "libres")
)
res1
res2
res1 <- xtradata_requete_aggregate(
typename = typename, key = key,
rangeStart = date_deb,
rangeEnd = date_fin,
rangeStep = "hour",
group = "time+gid",
attributes = list("gid", "libres")
)
res1 <- xtradata_requete_aggregate(
typename = typename, key = key,
rangeStart = date_deb,
rangeEnd = date_fin,
rangeStep = "hour",
group = "time+gid",
attributes = list("gid", "libres")
)
res2 <- xtradata_requete_aggregate(
typename = typename, key = key,
rangeStart = date_deb,
rangeEnd = date_fin,
rangeStep = "hour",
group = "time",
attributes = list("gid", "libres")
)
res2 <- xtradata_requete_aggregate(
typename = typename, key = key,
rangeStart = date_deb,
rangeEnd = date_fin,
rangeStep = "hour",
group = "time",
attributes = list("gid", "libres")
)
res1_grouped_by_time <- res1 %>%
dplyr::group_by(time) %>%
dplyr::summarise(libres = mean(libres, na.rm = TRUE))
all.equal(res1_grouped_by_time$libres, res2$libres)
setwd("../flourish/shiny-survey/")
shiny::runApp(".")
install.packages("nycflights13")
shiny::runApp(".")
shiny::runApp(".")
xtradata::xtradata_requete_aggregate
xtradata::xtradata_requete_features()
xtradata::xtradata_requete_features
#
devtools::check()
#
devtools::check()
#
devtools::check()
