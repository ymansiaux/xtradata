#' ]
#' }'
#'
#' filter_combined <- list("$and" = list(
#'   list("gid" = list(
#'     "$gte" = "1"
#'   )),
#'
#'   list("gid" = list(
#'     "$lte" = "5"
#'   ))
#' ))
#'
#' res9 <- xtradata_requete_features(
#'   typename = "ST_PARK_P", key = MaCle,
#'   filter = filterJSON_combined,
#' )
#'
#' res10 <- xtradata_requete_features(
#'   typename = "ST_PARK_P", key = MaCle,
#'   filter = filter_combined
#' )
#'
#' all.equal(res9, res10)
#'
#'
#' # possibilite de fournir un tableau de donnees dans l'argument filter
#'
#' filter_and <- list(
#'"gid" = list("$in" = c(247,593)
#')
#')
#'
#'
#'filter_and_JSON <- '{
#'"gid": {
#'  "$in": [
#'    247,593
#'  ]
#'}}'
#'
#'res11 <- xtradata_requete_aggregate(key = MaCle,
#'                                    typename = "ST_PARK_P",
#'                                    rangeStart = "2021-02-20", rangeEnd = "2021-02-21",
#'                                    rangeStep = "hour",
#'                                    attributes = list("gid", "libres", "total", "etat"),
#'                                    filter = filter_and)
#'
#'res12 <- xtradata_requete_aggregate(key = MaCle,
#'                                  typename = "ST_PARK_P",
#'                                    rangeStart = "2021-02-20", rangeEnd = "2021-02-21",
#'                                    rangeStep = "hour",
#'                                    attributes = list("gid", "libres", "total", "etat"),
#'                                    filter = filter_and_JSON)
#'all.equal(res11, res12)
#'}
#'
xtradata_requete_aggregate <- function(key = NULL,
typename  = NULL,
rangeStart = NULL,
rangeEnd = NULL,
rangeStep = NULL,
rangeFilter = list(
"hours" = 0:23,
"days" = 1:7,
"publicHolidays" = FALSE
),
attributes = NULL,
filter = NULL,
showURL = FALSE) {
assert_that(!is.null(typename))
assert_that(!is.null(key))
assert_that(!is.null(rangeStart))
check_internet()
base_url_xtradata_aggregate <-  glue("http://data.bordeaux-metropole.fr/geojson/aggregate/{typename}?")
if(is.string(filter))   filter <- fromJSON(filter)
if(is.string(rangeFilter))   rangeFilter <- fromJSON(rangeFilter)
if(is.string(attributes))   attributes <- fromJSON(attributes)
parametres_requete <- list("key" = key, "rangeStart" = rangeStart, "rangeEnd" = rangeEnd,
"rangeStep" = rangeStep, "rangeFilter" = rangeFilter,
"filter" = filter,  "attributes" = attributes) %>% compact()
params_encodes_pour_url <- map2(parametres_requete, names(parametres_requete), function(param, param_name) {
if(vec_depth(param) == 1 & length(param) == 1) {
# on doit transformer les listes et les vecteurs, si ce n'est pas le cas pas besoin de passer en JSON
parametre_encode <- param
} else {
# cette partie va gérer les tableaux. 1er if : tableau de lg 1, 2eme if : tableau de lg >1
if(length(unlist(param)) == 1)  {
parametre_encode <- toJSON(param, auto_unbox = FALSE) %>% URLencode()
} else {
parametre_encode <- toJSON(param, auto_unbox = TRUE) %>% URLencode()
}
}
glue('&{param_name}={parametre_encode}')
})
params_encodes_pour_url <- glue_collapse(params_encodes_pour_url, sep = "", width = Inf, last = "")
url <- glue("{base_url_xtradata_aggregate}{params_encodes_pour_url}")
if (showURL) print(url)
request <- suppressWarnings(GET(url))
check_API_results(request)
response <- content(request, as = "text", encoding = "UTF-8")
df <- fromJSON(response, flatten = TRUE)$features
if(length(df) > 0) {
colnames(df) <-  map_chr(colnames(df), ~gsub(x=  ., pattern = "properties.", replacement = ""))
}
return(as.data.frame(df))
}
skip_if_not(curl::has_internet(), "Pas de connexion internet")
MaCle <- "DATAZBOUBB"
filter <- list("type" = "BOUCLE",
"mdate" = list(
'$gt' = "2020-01-01T08:00:00")
)
filterJSON <-'{
"type": "BOUCLE",
"mdate": {
"$gt": "2020-01-01T08:00:00"
}
}'
res1 <- xtradata_requete_features(typename  = "PC_CAPTE_P", key = MaCle,
filter = filter)
res2 <- xtradata_requete_features(typename  = "PC_CAPTE_P", key = MaCle,
filter = filterJSON)
expect_gt(nrow(res1), 0)
expect_gt(nrow(res2), 0)
expect_equal(dim(res1), dim(res2))
expect_true(all.equal(res1, res2))
res1
res2
Sys.getlocale()
Sys.setlocale('LC_TIME', "French_France")
Sys.setlocale('LC_TIME', "Fr")
Sys.setlocale("LC_CTYPE","french")
options(encoding = "UTF-8")
Sys.setlocale("LC_CTYPE","french")
options(encoding = "UTF-8")
Sys.setlocale('LC_ALL','fr')
Sys.setlocale('LC_ALL','french')
test_that("recuperation de la couche des parkings hors voirie", {
skip_if_not(curl::has_internet(), "Pas de connexion internet")
MaCle <- "DATAZBOUBB"
req <- xtradata_requete_features(typename  = "ST_PARK_P", key = MaCle)
expect_s3_class(req, "data.frame")
expect_equal(nrow(req), 84)
})
Sys.setlocale('LC_ALL','C')
pkgload::load_all()
test_that("recuperation de la couche des parkings hors voirie", {
skip_if_not(curl::has_internet(), "Pas de connexion internet")
MaCle <- "DATAZBOUBB"
req <- xtradata_requete_features(typename  = "ST_PARK_P", key = MaCle)
expect_s3_class(req, "data.frame")
expect_equal(nrow(req), 84)
})
test_that("recuperation de la couche des parkings hors voirie", {
skip_if_not(curl::has_internet(), "Pas de connexion internet")
MaCle <- "DATAZBOUBB"
req <- xtradata_requete_features(typename  = "ST_PARK_P", key = MaCle)
expect_s3_class(req, "data.frame")
# expect_equal(nrow(req), 84)
})
test_that("Features : passage de attributes en vecteur R et en array resultats identiques", {
skip_if_not(curl::has_internet(), "Pas de connexion internet")
MaCle <- "DATAZBOUBB"
attributes <- list("cdate", "mdate")
attributesArray <- '["cdate", "mdate"]'
res1 <- xtradata_requete_features(typename  = "PC_CAPTE_P", key = MaCle,
attributes = attributes)
res2 <- xtradata_requete_features(typename  = "PC_CAPTE_P", key = MaCle,
attributes = attributesArray)
expect_gt(nrow(res1), 0)
expect_gt(nrow(res2), 0)
expect_equal(dim(res1), dim(res2))
expect_true(all.equal(res1, res2))
})
test_that("Features : passage de filter en liste R et en json resultats identiques", {
skip_if_not(curl::has_internet(), "Pas de connexion internet")
MaCle <- "DATAZBOUBB"
filter <- list("type" = "BOUCLE",
"mdate" = list(
'$gt' = "2020-01-01T08:00:00")
)
filterJSON <-'{
"type": "BOUCLE",
"mdate": {
"$gt": "2020-01-01T08:00:00"
}
}'
res1 <- xtradata_requete_features(typename  = "PC_CAPTE_P", key = MaCle,
filter = filter)
res2 <- xtradata_requete_features(typename  = "PC_CAPTE_P", key = MaCle,
filter = filterJSON)
expect_gt(nrow(res1), 0)
expect_gt(nrow(res2), 0)
expect_equal(dim(res1), dim(res2))
expect_true(all.equal(res1, res2))
})
test_that("Features : tests filtres combines dans filter", {
skip_if_not(curl::has_internet(), "Pas de connexion internet")
MaCle <- "DATAZBOUBB"
filterJSON_combined <- '{
"$and": [
{ "gid": {"$gte": "1"} },
{ "gid": {"$lte": "5"} }
]
}'
filter_combined <- list("$and" = list(
list("gid" = list(
"$gte" = "1"
)),
list("gid" = list(
"$lte" = "5"
))
))
res1 <- xtradata_requete_features(typename  = "PC_CAPTE_P", key = MaCle,
filter = filterJSON_combined)
res2 <- xtradata_requete_features(typename  = "PC_CAPTE_P", key = MaCle,
filter = filter_combined)
expect_gt(nrow(res1), 0)
expect_gt(nrow(res2), 0)
expect_equal(dim(res1), dim(res2))
expect_true(all.equal(res1, res2))
})
test_that("Aggregate : passage de filter en liste R et en json resultats identiques", {
skip_if_not(curl::has_internet(), "Pas de connexion internet")
MaCle <- "DATAZBOUBB"
filter <- list("ident" = "CUBPK88",
"etat" = "LIBRE",
"libres" = list(
'$gt' = 100)
)
filterJSON <- '{
"ident": "CUBPK88",
"etat" : "LIBRE",
"libres": {
"$gt": 100
}
}'
res1 <- xtradata_requete_aggregate(typename  = "ST_PARK_P", key = MaCle,
rangeStart = "2020-08-01",
rangeEnd = "2020-08-16",
rangeStep = "hour",
filter = filter)
res2 <- xtradata_requete_aggregate(typename  = "ST_PARK_P", key = MaCle,
rangeStart = "2020-08-01",
rangeEnd = "2020-08-16",
rangeStep = "hour",
filter = filterJSON)
expect_gt(nrow(res1), 0)
expect_gt(nrow(res2), 0)
expect_equal(dim(res1), dim(res2))
expect_true(all.equal(res1, res2))
})
test_that("Aggregate : passage de rangeFilter en liste R et en json resultats identiques", {
skip_if_not(curl::has_internet(), "Pas de connexion internet")
MaCle <- "DATAZBOUBB"
filter <- list("ident" = "CUBPK88",
"etat" = "LIBRE",
"libres" = list(
'$gt' = 100)
)
rangeFilter <- list("hours" = 5:6,
"days" = 1:7,
"publicHolidays" = FALSE
)
rangeFilterJSON <- '{
"hours": [
5,6
],
"days": [
1,2,3,4,5,6,7
],
"publicHolidays": false
}'
res1 <- xtradata_requete_aggregate(typename  = "ST_PARK_P", key = MaCle,
rangeStart = "2020-08-01",
rangeEnd = "2020-08-16",
rangeStep = "hour",
rangeFilter = rangeFilter,
attributes = list("gid", "libres", "total", "etat", "ident"),
filter = filter)
res2 <- xtradata_requete_aggregate(typename  = "ST_PARK_P", key = MaCle,
rangeStart = "2020-08-01",
rangeEnd = "2020-08-16",
rangeStep = "hour",
rangeFilter = rangeFilterJSON,
attributes = list("gid", "libres", "total", "etat", "ident"),
filter = filter)
expect_gt(nrow(res1), 0)
expect_gt(nrow(res2), 0)
expect_equal(dim(res1), dim(res2))
expect_true(all.equal(res1, res2))
})
test_that("Aggregate : passage de attributes en vecteur R et en array resultats identiques", {
skip_if_not(curl::has_internet(), "Pas de connexion internet")
MaCle <- "DATAZBOUBB"
filter <- list("ident" = "CUBPK88",
"etat" = "LIBRE",
"libres" = list(
'$gt' = 100)
)
rangeFilter <- list("hours" = 5:6,
"days" = 1:7,
"publicHolidays" = FALSE
)
attributes <- list("gid", "libres")
attributesArray <- '["gid", "libres"]'
res1 <- xtradata_requete_aggregate(typename  = "ST_PARK_P", key = MaCle,
rangeStart = "2020-08-01",
rangeEnd = "2020-08-16",
rangeStep = "hour",
rangeFilter = rangeFilter,
attributes = attributes,
filter = filter)
res2 <- xtradata_requete_aggregate(typename  = "ST_PARK_P", key = MaCle,
rangeStart = "2020-08-01",
rangeEnd = "2020-08-16",
rangeStep = "hour",
rangeFilter = rangeFilter,
attributes = attributesArray,
filter = filter)
expect_gt(nrow(res1), 0)
expect_gt(nrow(res2), 0)
expect_equal(dim(res1), dim(res2))
expect_true(all.equal(res1, res2))
})
test_that("Aggregate : passage de attributes en clé valeur en liste R et en json resultats identiques", {
skip_if_not(curl::has_internet(), "Pas de connexion internet")
MaCle <- "DATAZBOUBB"
filter <- list("ident" = "CUBPK88",
"etat" = "LIBRE",
"libres" = list(
'$gt' = 100)
)
rangeFilter <- list("hours" = 5:6,
"days" = 1:7,
"publicHolidays" = FALSE
)
attributes_key_value_list <- list("gid" = "first", "libres" = "max")
attributes_key_value_JSON <- '{"gid" : "first", "libres" : "max"}'
res1 <- xtradata_requete_aggregate(typename  = "ST_PARK_P", key = MaCle,
rangeStart = "2020-08-01",
rangeEnd = "2020-08-16",
rangeStep = "hour",
rangeFilter = rangeFilter,
attributes = attributes_key_value_list,
filter = filter)
res2 <- xtradata_requete_aggregate(typename  = "ST_PARK_P", key = MaCle,
rangeStart = "2020-08-01",
rangeEnd = "2020-08-16",
rangeStep = "hour",
rangeFilter = rangeFilter,
attributes = attributes_key_value_JSON,
filter = filter)
expect_gt(nrow(res1), 0)
expect_gt(nrow(res2), 0)
expect_equal(dim(res1), dim(res2))
expect_true(all.equal(res1, res2))
})
test_that("Aggregate : tests filtres combines dans filter", {
skip_if_not(curl::has_internet(), "Pas de connexion internet")
MaCle <- "DATAZBOUBB"
filterJSON_combined <- '{
"$and": [
{ "total": {"$gte": 500} },
{ "total": {"$lte": 1000} }
]
}'
filter_combined <- list("$and" = list(
list("total" = list(
"$gte" = 500
)),
list("total" = list(
"$lte" = 1000
))
))
res1 <- xtradata_requete_aggregate(typename  = "ST_PARK_P", key = MaCle,
rangeStart = "2020-08-01",
rangeEnd = "2020-08-16",
filter = filterJSON_combined)
res2 <- xtradata_requete_aggregate(typename  = "ST_PARK_P", key = MaCle,
rangeStart = "2021-01-01",
rangeEnd = "2021-01-16",
filter = filter_combined)
expect_gt(nrow(res1), 0)
expect_gt(nrow(res2), 0)
expect_equal(dim(res1), dim(res2))
expect_true(all.equal(res1, res2))
})
res1
res2
res1 <- xtradata_requete_aggregate(typename  = "ST_PARK_P", key = MaCle,
rangeStart = "2020-08-01",
rangeEnd = "2020-08-16",
filter = filterJSON_combined)
MaCle <- DATABOUBB
MaCle <- "DATAZBOUBB"
skip_if_not(curl::has_internet(), "Pas de connexion internet")
MaCle <- "DATAZBOUBB"
filterJSON_combined <- '{
"$and": [
{ "total": {"$gte": 500} },
{ "total": {"$lte": 1000} }
]
}'
filter_combined <- list("$and" = list(
list("total" = list(
"$gte" = 500
)),
list("total" = list(
"$lte" = 1000
))
))
res1 <- xtradata_requete_aggregate(typename  = "ST_PARK_P", key = MaCle,
rangeStart = "2020-08-01",
rangeEnd = "2020-08-16",
filter = filterJSON_combined)
res1
res1$total
res1$total %>% summary()
filter_combined <- list("$and" = list(
list("total" = list(
"$gte" = 500
)),
list("total" = list(
"$lte" = 1000
))
))
res2 <- xtradata_requete_aggregate(typename  = "ST_PARK_P", key = MaCle,
rangeStart = "2021-01-01",
rangeEnd = "2020-08-16",
filter = filter_combined)
res2 <- xtradata_requete_aggregate(typename  = "ST_PARK_P", key = MaCle,
rangeStart = "2020-08-01",
rangeEnd = "2020-08-16",
filter = filter_combined)
expect_gt(nrow(res1), 0)
expect_gt(nrow(res2), 0)
expect_equal(dim(res1), dim(res2))
expect_true(all.equal(res1, res2))
(all.equal(res1, res2))
#
devtools::check()
devtools::build(vignettes = TRUE)
devtools::install()
library(xtradata)
?xtradata_requete_aggregate
filterJSON <- '{
"ident": "CUBPK88",
"etat" : "LIBRE",
"libres": {
"$gt": 100
}
}'
MaCle <- "DATAZBOUBB"
res2 <- xtradata_requete_aggregate(typename  = "ST_PARK_P", key = MaCle,
rangeStart = "2020-08-01",
rangeEnd = "2020-08-16",
rangeStep = "hour",
filter = filterJSON)
res2
filterJSON <- '{
"ident": "CUBPK88",
"etat" : "LIBRE",
"libres": {
"$gt": 100000000
}
}'
res2
res2 <- xtradata_requete_aggregate(typename  = "ST_PARK_P", key = MaCle,
rangeStart = "2020-08-01",
rangeEnd = "2020-08-16",
rangeStep = "hour",
filter = filterJSON)
res2
devtools::install()
pkgload::load_all()
check_API_results <- function(requete) {
assert_that(
status_code(requete) == 200,
msg = paste("The API request returned an error, API response code :", status_code(requete))
)
return(status_code(requete))
}
check_API_results(xtradata_requete_features(key = "DATAZBOUBB", typename = "ST_PARK_P"))
xtradata_requete_features(key = "DATAZBOUBB", typename = "ST_PARK_P", showURL = TRUE)
url <- "http://data.bordeaux-metropole.fr/geojson/features/ST_PARK_P?&key=DATAZBOUBB&crs=epsg:4326"
check_API_results(url)
check_API_results(GET(url))
url <- "http://data.bordeaux-metropole.fr/geojson/features/ST_PARK_P?&key=DATAZBOBB&crs=epsg:4326"
check_API_results(GET(url))
check_API_results(GET(url)) -> a
a
a<- try(check_API_results(GET(url)) )
a
attributes(a)
attributes(a)$condition
a<- try(check_API_results(GET(url)) )
attributes(a)$condition
b <- attributes(a)$condition
grep(pattern = "\d{3,}", x = b)
grep(pattern = "\\d{3,}", x = b)
v
b
class(b)
as.character(b)
grep(pattern = "\\d{3,}", x = as.character(b))
?grep
regexpr(pattern = "\\d{3,}", x = as.character(b))
regexpr(pattern = "\\d{3,}", text = as.character(b))
gregexpr(pattern = "\\d{3,}", text = as.character(b))
regmatches(as.character(b),regexpr(pattern = "\\d{3,}", text = as.character(b)))
