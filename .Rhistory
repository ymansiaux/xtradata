#'
#' @return un data frame issu de la requête
#' @export
#'
#' @importFrom assertthat assert_that is.string
#' @importFrom glue glue glue_collapse
#' @importFrom purrr map2 compact vec_depth map_chr
#' @importFrom httr GET content
#' @importFrom jsonlite fromJSON toJSON
#' @importFrom utils URLencode
#'
#' @references http://data.bordeaux-metropole.fr/geojson/help/
#' @references https://data.bordeaux-metropole.fr/dicopub/#/dico
#'
#' @examples
#' \dontrun{
#' # appel sur la couche PC_CAPTE_P
#' filter <- list(
#'   "type" = "BOUCLE",
#'   "mdate" = list(
#'     "$gt" = "2020-01-01T08:00:00"
#'   )
#' )
#'
#'
#' filterJSON <- '{
#' "type": "BOUCLE",
#' "mdate": {
#'   "$gt": "2020-01-01T08:00:00"
#'  }
#' }'
#'
#' # 2 façons d'utiliser le paramètre filter
#' res1 <- xtradata_requete_features(
#'   typename = "PC_CAPTE_P", key = MaCle,
#'   filter = filter
#' )
#'
#' res2 <- xtradata_requete_features(
#'   typename = "PC_CAPTE_P", key = MaCle,
#'   filter = filterJSON
#' )
#'
#' all.equal(res1, res2)
#'
#' # 2 façons d'utiliser le paramètre attributes
#'
#' attributes <- list("cdate", "mdate")
#' attributesArray <- '["cdate", "mdate"]'
#'
#' res3 <- xtradata_requete_features(
#'   typename = "PC_CAPTE_P", key = MaCle,
#'   filter = filter, attributes = attributes
#' )
#'
#' res4 <- xtradata_requete_features(
#'   typename = "PC_CAPTE_P", key = MaCle,
#'   filter = filter, attributes = attributesArray
#' )
#'
#' all.equal(res3, res4)
#'
#' # limitation de la requete au 10 premiers resultats
#' res5 <- xtradata_requete_features(
#'   typename = "PC_CAPTE_P", key = MaCle,
#'   maxfeatures = 10
#' )
#' nrow(res5)
#'
#'
#' # les filtres sur un meme champ doivent etre combines avec les operateurs
#' # '$and', '$or', '$not'
#'
#' filterJSON_combined <- '{
#' "$and": [
#'  { "gid": {"$gte": "1"} },
#'  { "gid": {"$lte": "5"} }
#' ]
#' }'
#'
#' filter_combined <- list("$and" = list(
#'   list("gid" = list(
#'     "$gte" = "1"
#'   )),
#'
#'   list("gid" = list(
#'     "$lte" = "5"
#'   ))
#' ))
#'
#' res6 <- xtradata_requete_features(
#'   typename = "PC_CAPTE_P", key = MaCle,
#'   filter = filterJSON_combined
#' )
#'
#' res7 <- xtradata_requete_features(
#'   typename = "PC_CAPTE_P", key = MaCle,
#'   filter = filter_combined
#' )
#'
#' all.equal(res6, res7)
#'
#' # possibilite de fournir un tableau de donnees dans l'argument filter
#' filter_and <- list(
#'   "gid" = list("$in" = c(50:55))
#' )
#'
#'
#' filter_and_JSON <- '{
#' "gid": {
#'  "$in": [
#'    50,51,52,53,54,55
#'  ]
#' }}'
#'
#' res8 <- xtradata_requete_features(
#'   typename = "PC_CAPTE_P", key = MaCle,
#'   filter = filter_and
#' )
#'
#' res9 <- xtradata_requete_features(
#'   typename = "PC_CAPTE_P", key = MaCle,
#'   filter = filter_and_JSON
#' )
#'
#' all.equal(res8, res9)
#'
#' # Utilisation de l'argument backintime avec une date ou un datetime
#'
#'filter <- list(
#' "type" = "BOUCLE",
#' "mdate" = list(
#'   "$gt" = "2020-01-01T08:00:00"
#' )
#' )
#'
#' res10 <- xtradata_requete_features(
#'   typename = "PC_CAPTE_P", key = MaCle,
#'   filter = filter,
#'   backintime = "2021-06-01T10:00:00"
#' )
#'
#' tail(res10$mdate)
#'
#' res11 <- xtradata_requete_features(
#'   typename = "PC_CAPTE_P", key = MaCle,
#'   filter = filter,
#'   backintime = "2021-06-01"
#' )
#'
#' tail(res11$mdate)
#'
#' #' # Utilisation de l'argument backintime avec ne macro relative à la date / heure actuelle
#' #' #  composée d'un nombre et d'une unité parmi min, hour, day ou month
#'
#' res12 <- xtradata_requete_features(
#'   typename = "PC_CAPTE_P", key = MaCle,
#'   filter = filter,
#'   backintime = "-30min"
#' )
#'
#' tail(res12$mdate)
#'
#'
#' res13 <- xtradata_requete_features(
#'   typename = "PC_CAPTE_P", key = MaCle,
#'   filter = filter,
#'   backintime = "-5hour"
#' )
#'
#' tail(res13$mdate)
#'
#' res14 <- xtradata_requete_features(
#'   typename = "PC_CAPTE_P", key = MaCle,
#'   filter = filter,
#'   backintime = "-7day"
#' )
#'
#' tail(res14$mdate)
#'
#'
#' res15 <- xtradata_requete_features(
#'   typename = "PC_CAPTE_P", key = MaCle,
#'   filter = filter,
#'   backintime = "-1month"
#' )
#'
#' tail(res15$mdate)
#'
#' # 2 façons d'utiliser le paramètre orderby
#' orderby <- list("mdate", "gid")
#' orderbyArray <- '["mdate", "gid"]'
#'
#' res16 <- xtradata_requete_features(
#'   typename = "PC_CAPTE_P", key = MaCle,
#'   filter = filter,
#'   orderby = orderby,
#'   showURL = TRUE
#' )
#'
#' res17 <- xtradata_requete_features(
#'   typename = "PC_CAPTE_P", key = MaCle,
#'   filter = filter,
#'   orderby = orderbyArray,
#'   showURL = TRUE
#' )
#' res17
#'
#' all.equal(res16, res17)
#'}
#'
xtradata_requete_features <- function(key = NULL,
typename = NULL,
crs = "epsg:4326",
filter = NULL,
attributes = NULL,
maxfeatures = NULL,
orderby = NULL,
backintime = NULL,
showURL = FALSE,
useHTTPS = TRUE) {
assert_that(!is.null(typename))
assert_that(!is.null(key))
assert_that(crs %in% c("epsg:4326", "epsg:3945", "epsg:2154", "epsg:3857"),
msg = 'Les valeurs de crs autorisees sont "epsg:4326", "epsg:3945", "epsg:2154", "epsg:3857"'
)
check_internet()
base_url_xtradata_features <- ifelse(useHTTPS, glue("https://data.bordeaux-metropole.fr/geojson/features/{typename}?"),
glue("http://data.bordeaux-metropole.fr/geojson/features/{typename}?"))
if (is.string(filter)) filter <- fromJSON(filter)
if (is.string(attributes)) attributes <- fromJSON(attributes)
if (is.string(orderby)) orderby <- fromJSON(orderby)
parametres_requete <- list(
"filter" = filter,
"key" = key, "crs" = crs,
"attributes" = attributes,
"maxfeatures" = maxfeatures,
"backintime" = backintime,
"orderby" = orderby
) %>% compact()
params_encodes_pour_url <- map2(parametres_requete, names(parametres_requete), function(param, param_name) {
if (vec_depth(param) == 1 & length(param) == 1) {
# on gere ici les elements à un niveau clé <-> valeur : ex key = MaCle ou rangeStart = une date quelconque
parametre_encode <- param
} else {
# ici element plus complexes, ex les listes avec des sous niveau : les filters ou les rangeStep
parametre_encode <- toJSON(param, auto_unbox = TRUE) %>% URLencode()
}
glue("&{param_name}={parametre_encode}")
})
params_encodes_pour_url <- glue_collapse(params_encodes_pour_url, sep = "", width = Inf, last = "")
url <- glue("{base_url_xtradata_features}{params_encodes_pour_url}")
if (showURL) print(url)
browser()
request <- suppressWarnings(GET(url))
check_API_results(request)
response <- content(request, as = "text", encoding = "UTF-8")
df <- fromJSON(response, flatten = TRUE)$features
if (length(df) > 0) {
colnames(df) <- map_chr(colnames(df), ~ gsub(x = ., pattern = "properties.", replacement = ""))
}
return(as.data.frame(df))
}
filter <- list(
"type" = "BOUCLE",
"mdate" = list(
"$gt" = "2020-01-01T08:00:00"
)
)
filterJSON <- '{
"type": "BOUCLE",
"mdate": {
"$gt": "2020-01-01T08:00:00"
}
}'
# 2 façons d'utiliser le paramètre filter
res1 <- xtradata_requete_features(
typename = "PC_CAPTE_P", key = MaCle,
filter = filter
)
request <- suppressWarnings(GET(url))
url
request <- fromJSON(url)
request
check_API_results
status_code(request)
request$type
request$features
curl::curl_fetch_memory(url)
usethis::edit_r_environ()
usethis::edit_r_profile()
usethis::edit_rstudio_prefs()
renv::status()
renv::snapshot()
devtools::load_all()
a <- xtradata_requete_features(key = "DATAZBOUBB", typename = "ST_PARK_P")
# version OK
url <- "https://data.bordeaux-metropole.fr/geojson/features/PC_CAPTE_P?&filter=%7B%22type%22:%22BOUCLE%22,%22mdate%22:%7B%22$gt%22:%222020-01-01T08:00:00%22%7D%7D&key=DATAZBOUBB&crs=epsg:4326&attributes=[%22cdate%22,%22mdate%22]"
req <- curl::curl_fetch_memory(url)
response <- rawToChar(req$content)
st_as_sfc(response, GeoJSON = TRUE)
library(sf)
st_as_sfc(response, GeoJSON = TRUE)
geojson_sf(response)
??geojson_sf
library(geojsonsf)
geojson_sf(response)
attributes <- list("cdate", "mdate")
attributesArray <- '["cdate", "mdate"]'
filter <- list(
"type" = "BOUCLE",
"mdate" = list(
"$gt" = "2020-01-01T08:00:00"
)
)
filterJSON <- '{
"type": "BOUCLE",
"mdate": {
"$gt": "2020-01-01T08:00:00"
}
}'
res3 <- xtradata_requete_features(
typename = "PC_CAPTE_P", key = "DATAZBOUBB",
filter = filter, attributes = attributes, showURL = TRUE
)
url <- "https://data.bordeaux-metropole.fr/geojson/features/PC_CAPTE_P?&filter=%7B%22type%22:%22BOUCLE%22,%22mdate%22:%7B%22$gt%22:%222020-01-01T08:00:00%22%7D%7D&key=DATAZBOUBB&crs=epsg:4326&attributes=[%22cdate%22,%22mdate%22]"
req <- curl::curl_fetch_memory(url)
response <- rawToChar(req$content)
st_as_sfc(response, GeoJSON = TRUE)
geojson_sf(response)
a <- xtradata_requete_features(key = "DATAZBOUBB", typename = "ST_PARK_P", showURL = TRUE)
# version OK
url <- "https://data.bordeaux-metropole.fr/geojson/features/ST_PARK_P?&key=DATAZBOUBB&crs=epsg:4326
"
# version OK
url <- "https://data.bordeaux-metropole.fr/geojson/features/ST_PARK_P?&key=DATAZBOUBB&crs=epsg:4326
"
# version OK
url <- "https://data.bordeaux-metropole.fr/geojson/features/ST_PARK_P?&key=DATAZBOUBB&crs=epsg:4326"
req <- curl::curl_fetch_memory(url)
response <- rawToChar(req$content)
st_as_sfc(response, GeoJSON = TRUE)
geojson_sf(response)
req <- curl::curl_fetch_memory(url)
response <- rawToChar(req$content)
geojson_sf(response)
url <- "https://data.bordeaux-metropole.fr/geojson/features/PC_CAPTE_P?&filter=%7B%22type%22:%22BOUCLE%22,%22mdate%22:%7B%22$gt%22:%222020-01-01T08:00:00%22%7D%7D&key=DATAZBOUBB&crs=epsg:4326&attributes=[%22cdate%22,%22mdate%22]"
req <- curl::curl_fetch_memory(url)
response <- rawToChar(req$content)
st_as_sfc(response, GeoJSON = TRUE)
geojson_sf(response)
fromJSON(response)
# on appelle
fromJSON(response)
# on appelle
fromJSON(response)$features
check_API_results
response
req
check_API_results
status_code
check_API_results(req)
check_API_results
install.packages("attachment")
attachment::att_amend_desc()
# version OK
url <- "https://data.bordeaux-metropole.fr/geojson/features/ST_PARK_P?&key=DATAZBOUBB&crs=epsg:4326"
req <- curl::curl_fetch_memory(url)
response <- rawToChar(req$content)
# si ca renvoie une erreur
geojson_sf(response)
resultats <- try(geojson_sf(response))
resultats
url <- "https://data.bordeaux-metropole.fr/geojson/features/PC_CAPTE_P?&filter=%7B%22type%22:%22BOUCLE%22,%22mdate%22:%7B%22$gt%22:%222020-01-01T08:00:00%22%7D%7D&key=DATAZBOUBB&crs=epsg:4326&attributes=[%22cdate%22,%22mdate%22]"
req <- curl::curl_fetch_memory(url)
response <- rawToChar(req$content)
st_as_sfc(response, GeoJSON = TRUE)
resultats <- try(geojson_sf(response))
resultats
inherits(resultats, "try-error")
check_API_results
request
req <- curl::curl_fetch_memory(url)
req
req$status_code
#' @param requete requete sur l'API d'interet
#'
#' @return un booleen (status = 200 : TRUE / FALSE)
#' @importFrom assertthat assert_that
#'
#' @export
#'
#' @examples
#' requete <- httr::GET("http://www.google.com")
#' check_API_results(requete = requete)
check_API_results <- function(requete) {
assert_that(
requete$status_code == 200,
msg = paste("The API request returned an error, API response code :", status_code(requete))
)
}
rawToChar
devtools::load_all()
a <- xtradata_requete_features(key = "DATAZBOUBB", typename = "ST_PARK_P", showURL = TRUE)
curl
attachment::att_amend_desc()
devtools::load_all()
a <- xtradata_requete_features(key = "DATAZBOUBB", typename = "ST_PARK_P", showURL = TRUE)
devtools::load_all()
a <- xtradata_requete_features(key = "DATAZBOUBB", typename = "ST_PARK_P", showURL = TRUE)
request <- curl_fetch_memory(url)
check_API_results(request)
response <- rawToChar(req$content)
df <- try(geojson_sf(response))
df
devtools::load_all()
a <- xtradata_requete_features(key = "DATAZBOUBB", typename = "ST_PARK_P", showURL = TRUE)
a
devtools::load_all()
a <- xtradata_requete_features(key = "DATAZBOUBB", typename = "ST_PARK_P", showURL = TRUE)
a
devtools::load_all()
a <- xtradata_requete_features(key = "DATAZBOUBB", typename = "ST_PARK_P", showURL = TRUE)
a
class(a)
a$geometry
st_as_sf(a)
library(sf)
st_as_sf(a)
a
attributes <- list("cdate", "mdate")
attributesArray <- '["cdate", "mdate"]'
filter <- list(
"type" = "BOUCLE",
"mdate" = list(
"$gt" = "2020-01-01T08:00:00"
)
)
filterJSON <- '{
"type": "BOUCLE",
"mdate": {
"$gt": "2020-01-01T08:00:00"
}
}'
res3 <- xtradata_requete_features(
typename = "PC_CAPTE_P", key = "DATAZBOUBB",
filter = filter, attributes = attributes, showURL = TRUE
)
res3
skip_if_not(curl::has_internet(), "Pas de connexion internet")
MaCle <- Sys.getenv("XTRADATA_KEY")
req <- xtradata_requete_features(typename  = "ST_PARK_P", key = MaCle)
req
class(req)
expect_s3_class(req, "data.frame")
expect_s3_class(req, c("sf","data.frame"))
devtools::load_all()
#
vignettes <- TRUE
attachment::att_amend_desc()
devtools::check()
#
vignettes <- FALSE
attachment::att_amend_desc()
devtools::check()
#
vignettes <- FALSE
attachment::att_amend_desc()
devtools::check(vignettes = vignettes)
check_API_results(curl::curl_fetch_memory("www.google.fr"))
devtools::check(vignettes = vignettes)
attachment::att_amend_desc()
devtools::check(vignettes = vignettes)
devtools::check(vignettes = vignettes)
devtools::check(vignettes = vignettes)
attachment::att_amend_desc()
devtools::check(vignettes = vignettes)
devtools::build(vignettes = vignettes)
devtools::build(vignettes = vignettes)
devtools::install(build_vignettes = vignettes)
knitr::opts_chunk$set(echo = TRUE)
library(xtradata)
key <- Sys.getenv("XTRADATA_KEY")
# Couche des capteurs de trafic auto
typename <- "PC_CAPTE_P"
# key <- "VOTRE_CLE_OPEN_DATA"
requete <- xtradata_requete_features(key = key, typename = typename)
head(requete)
# Couche des capteurs de trafic auto
typename <- "PC_CAPTE_P"
# key <- "VOTRE_CLE_OPEN_DATA"
requete <- xtradata_requete_features(key = key, typename = typename)
head(requete)
library(xtradata)
#
vignettes <- TRUE
attachment::att_amend_desc()
devtools::check(vignettes = vignettes)
devtools::build(vignettes = vignettes)
devtools::install(build_vignettes = vignettes)
vignettes
devtools::install(build_vignettes = vignettes)
renv::status()
renv::snapshot()
devtools::install(build_vignettes = vignettes)
#
vignettes <- TRUE
devtools::install(build_vignettes = vignettes)
#
vignettes <- TRUE
devtools::install(build_vignettes = vignettes)
library(xtradata)
